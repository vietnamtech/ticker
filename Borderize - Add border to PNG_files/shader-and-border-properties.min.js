class Shader {
    constructor(gl, vertexShader, fragmentShader) {
        let compiledVertexShader = this.compileShader(gl, "vertex", vertexShader)
          , compiledFragmentShader = this.compileShader(gl, "fragment", fragmentShader);
        this.shaderProgram = gl.createProgram(),
        gl.attachShader(this.shaderProgram, compiledVertexShader),
        gl.attachShader(this.shaderProgram, compiledFragmentShader),
        gl.linkProgram(this.shaderProgram),
        gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS) || console.error("Couldn't link the shader program"),
        gl.deleteShader(compiledVertexShader),
        gl.deleteShader(compiledFragmentShader)
    }
    use(gl) {
        gl.useProgram(this.shaderProgram)
    }
    setVertexAttribArray(gl, name, size, type, normalized, stride, offset) {
        let location = gl.getAttribLocation(this.shaderProgram, name);
        gl.enableVertexAttribArray(location),
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset)
    }
    setIntUniform(gl, name, value) {
        let location = gl.getUniformLocation(this.shaderProgram, name);
        gl.uniform1i(location, value)
    }
    setFloatUniform(gl, name, value) {
        let location = gl.getUniformLocation(this.shaderProgram, name);
        gl.uniform1f(location, value)
    }
    setVec4Uniform(gl, name, x, y, z, w) {
        let location = gl.getUniformLocation(this.shaderProgram, name);
        gl.uniform4f(location, x, y, z, w)
    }
    compileShader(gl, shaderType, shaderSrc) {
        let shader;
        if ("fragment" == shaderType)
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        else {
            if ("vertex" != shaderType)
                return console.error(`Shader type: ${shaderType} unhandled`),
                null;
            shader = gl.createShader(gl.VERTEX_SHADER)
        }
        return gl.shaderSource(shader, shaderSrc),
        gl.compileShader(shader),
        gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : (console.error(gl.getShaderInfoLog(shader)),
        null)
    }
}
class BorderProperties {
    constructor(borderSize, shadowSize, borderColor, shadowColor, shadowAlpha, shadowBlurStrength) {
        this.borderSize = borderSize,
        this.shadowSize = shadowSize,
        this.borderColor = borderColor,
        this.shadowColor = shadowColor,
        this.shadowAlpha = shadowAlpha,
        this.shadowBlurStrength = shadowBlurStrength
    }
    get borderSize() {
        return this._boderSize
    }
    set borderSize(size) {
        isNaN(size) || size < 0 ? console.warn(`Invalid value for the border size: ${size}`) : this._boderSize = size
    }
    get shadowSize() {
        return this._shadowSize
    }
    set shadowSize(size) {
        isNaN(size) || size < 0 ? console.warn(`Invalid value for the shadow size: ${size}`) : this._shadowSize = size
    }
    get extraSize() {
        return this._boderSize + this._shadowSize
    }
    get borderColor() {
        return this._borderColor
    }
    set borderColor(value) {
        return !Array.isArray(value) || value.length > 3 ? (console.warn("The border color has to be an array of size 3"),
        this._borderColor) : value.reduce((previous,current)=>previous || current < 0 || current > 255, !1) ? (console.warn("Each component of the border color has to be in the range [0,255]"),
        this._borderColor) : (this._borderColor = value.map(x=>x),
        this._borderColor)
    }
    get shadowColor() {
        return this._shadowColor
    }
    set shadowColor(value) {
        return !Array.isArray(value) || value.length > 3 ? (console.warn("The shadow color has to be an array of size 3"),
        this._shadowColor) : value.reduce((previous,current)=>previous || current < 0 || current > 255, !1) ? (console.warn("Each component of the shadow color has to be in the range [0,255]"),
        this._shadowColor) : (this._shadowColor = value.map(x=>x),
        this._shadowColor)
    }
    get shadowAlpha() {
        return this._shadowAlpha
    }
    set shadowAlpha(value) {
        isNaN(value) || value < 0 || value > 255 ? console.warn(`Invalid value for the shadow alpha: ${value}`) : this._shadowAlpha = value
    }
    get shadowBlurStrength() {
        return this._shadowBlurStrength
    }
    set shadowBlurStrength(value) {
        isNaN(value) || value < 0 || value > 1 ? console.warn(`Invalid value for the shadow blur strength: ${value}`) : this._shadowBlurStrength = value
    }
}
